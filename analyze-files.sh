#!/bin/bash

# =============================================================================
# File Analysis and Inspection Script
# =============================================================================
# Comprehensive analysis tool for output files generated by processing jobs.
# Provides statistics on file counts, sizes, types, and identifies potential issues.
#
# Usage: ./analyze-files.sh [options]
# Options:
#   -h, --help          Show this help message
#   -v, --verbose       Enable verbose output with detailed file listings
#   -s, --summary       Show only summary statistics (default)
#   -d, --directory DIR Add additional directory to analyze
#   -e, --extension EXT Focus on specific file extension
#   -z, --zero-files    Show zero-byte files
#   -l, --large-files   Show largest files
#   -r, --recent HOURS  Show files modified in last N hours
#   -t, --tree          Show directory tree structure

set -euo pipefail

# Source the centralized configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/config.sh"

# Script-specific variables
VERBOSE=false
SUMMARY_ONLY=true
ADDITIONAL_DIRS=()
SPECIFIC_EXTENSION=""
SHOW_ZERO_FILES=false
SHOW_LARGE_FILES=false
RECENT_HOURS=""
SHOW_TREE=false

# Analysis results storage
declare -A dir_file_counts
declare -A dir_total_sizes
declare -A extension_counts
declare -A extension_sizes
declare -a zero_files
declare -a large_files
declare -a recent_files

# Function to display help
show_help() {
    cat << EOF
File Analysis and Inspection Script

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help              Show this help message and exit
    -v, --verbose           Enable verbose output with detailed file listings
    -s, --summary           Show only summary statistics (default)
    -d, --directory DIR     Add additional directory to analyze
    -e, --extension EXT     Focus on specific file extension (without dot)
    -z, --zero-files        Show zero-byte files
    -l, --large-files       Show largest files (top 10)
    -r, --recent HOURS      Show files modified in last N hours
    -t, --tree              Show directory tree structure

DESCRIPTION:
    This script analyzes output files generated by processing jobs, providing:
    - File count and size statistics by directory
    - File type breakdown by extension
    - Detection of zero-byte or potentially corrupt files
    - Identification of largest files for space management
    - Recent file activity analysis
    - Directory structure visualization

    Default directories analyzed: ${OUTPUT_DIRS[*]}
    Default file extensions tracked: ${TRACKED_EXTENSIONS[*]}

EXAMPLES:
    $0                          # Show file analysis summary
    $0 -v                       # Show detailed file analysis
    $0 -d /path/to/custom/dir   # Include custom directory
    $0 -e json                  # Focus on JSON files only
    $0 -z -l                    # Show zero-byte and largest files
    $0 -r 24                    # Show files from last 24 hours
    $0 -t                       # Show directory tree structure

EOF
}

# Function to parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                SUMMARY_ONLY=false
                shift
                ;;
            -s|--summary)
                SUMMARY_ONLY=true
                VERBOSE=false
                shift
                ;;
            -d|--directory)
                if [[ -n "${2:-}" ]]; then
                    ADDITIONAL_DIRS+=("$2")
                    shift 2
                else
                    print_colored "$COLOR_RED" "Error: --directory requires a directory path"
                    exit 1
                fi
                ;;
            -e|--extension)
                if [[ -n "${2:-}" ]]; then
                    SPECIFIC_EXTENSION="$2"
                    shift 2
                else
                    print_colored "$COLOR_RED" "Error: --extension requires an extension name"
                    exit 1
                fi
                ;;
            -z|--zero-files)
                SHOW_ZERO_FILES=true
                shift
                ;;
            -l|--large-files)
                SHOW_LARGE_FILES=true
                shift
                ;;
            -r|--recent)
                if [[ -n "${2:-}" && "$2" =~ ^[0-9]+$ ]]; then
                    RECENT_HOURS="$2"
                    shift 2
                else
                    print_colored "$COLOR_RED" "Error: --recent requires a number of hours"
                    exit 1
                fi
                ;;
            -t|--tree)
                SHOW_TREE=true
                shift
                ;;
            *)
                print_colored "$COLOR_RED" "Unknown option: $1"
                echo "Use -h or --help for usage information."
                exit 1
                ;;
        esac
    done
}

# Function to check if file matches extension filter
matches_extension() {
    local file="$1"
    
    if [[ -z "$SPECIFIC_EXTENSION" ]]; then
        return 0  # No filter
    fi
    
    local file_ext
    file_ext=$(echo "${file##*.}" | tr '[:upper:]' '[:lower:]')
    local filter_ext
    filter_ext=$(echo "$SPECIFIC_EXTENSION" | tr '[:upper:]' '[:lower:]')
    
    [[ "$file_ext" == "$filter_ext" ]]
}

# Function to check if file is recent enough
is_file_recent() {
    local file="$1"
    local hours="$2"
    
    if [[ -z "$hours" ]]; then
        return 0  # No time filter
    fi
    
    local file_time
    file_time=$(stat -c %Y "$file" 2>/dev/null || echo "0")
    local current_time
    current_time=$(date +%s)
    local cutoff_time=$((current_time - hours * 3600))
    
    [[ $file_time -gt $cutoff_time ]]
}

# Function to get file extension
get_file_extension() {
    local file="$1"
    local basename_file
    basename_file=$(basename "$file")
    
    if [[ "$basename_file" == *.* ]]; then
        echo "${basename_file##*.}" | tr '[:upper:]' '[:lower:]'
    else
        echo "no_extension"
    fi
}

# Function to analyze a single directory
analyze_directory() {
    local dir="$1"
    local dir_name
    dir_name=$(basename "$dir")
    
    if [[ ! -d "$dir" ]]; then
        print_colored "$COLOR_YELLOW" "Warning: Directory does not exist: $dir"
        return
    fi
    
    if [[ ! -r "$dir" ]]; then
        print_colored "$COLOR_YELLOW" "Warning: Cannot read directory: $dir"
        return
    fi
    
    local file_count=0
    local total_size=0
    
    print_colored "$COLOR_CYAN" "Analyzing directory: $dir"
    
    # Process all files in directory (including subdirectories)
    while IFS= read -r -d '' file; do
        # Skip if not a regular file
        if [[ ! -f "$file" ]]; then
            continue
        fi
        
        # Apply extension filter
        if ! matches_extension "$file"; then
            continue
        fi
        
        local file_size
        file_size=$(stat -c %s "$file" 2>/dev/null || echo "0")
        
        # Track recent files
        if [[ -n "$RECENT_HOURS" ]] && is_file_recent "$file" "$RECENT_HOURS"; then
            recent_files+=("$file:$file_size")
        fi
        
        # Track zero-byte files
        if [[ $file_size -eq 0 ]]; then
            zero_files+=("$file")
        fi
        
        # Track large files (>100MB)
        if [[ $file_size -gt 104857600 ]]; then
            large_files+=("$file:$file_size")
        fi
        
        # Update counters
        file_count=$((file_count + 1))
        total_size=$((total_size + file_size))
        
        # Track by extension
        local ext
        ext=$(get_file_extension "$file")
        extension_counts["$ext"]=$((${extension_counts["$ext"]:-0} + 1))
        extension_sizes["$ext"]=$((${extension_sizes["$ext"]:-0} + file_size))
        
        # Show progress for large directories
        if [[ $((file_count % 1000)) -eq 0 ]]; then
            echo -n "."
        fi
        
    done < <(find "$dir" -type f -print0 2>/dev/null)
    
    # Store directory results
    dir_file_counts["$dir_name"]=$file_count
    dir_total_sizes["$dir_name"]=$total_size
    
    if [[ $file_count -gt 1000 ]]; then
        echo  # New line after progress dots
    fi
    
    print_colored "$COLOR_GREEN" "  Files: $file_count, Total size: $(format_bytes $total_size)"
}

# Function to display directory summary
display_directory_summary() {
    if [[ ${#dir_file_counts[@]} -eq 0 ]]; then
        print_colored "$COLOR_YELLOW" "No directories analyzed."
        return
    fi
    
    print_colored "$COLOR_BLUE" "=== Directory Summary ==="
    echo
    
    local total_files=0
    local total_size=0
    
    printf "%-30s %15s %15s\n" "Directory" "Files" "Total Size"
    printf "%-30s %15s %15s\n" "$(printf '%*s' 30 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')"
    
    for dir in "${!dir_file_counts[@]}"; do
        local file_count="${dir_file_counts[$dir]}"
        local dir_size="${dir_total_sizes[$dir]}"
        
        printf "%-30s %15s %15s\n" "$dir" "$file_count" "$(format_bytes $dir_size)"
        
        total_files=$((total_files + file_count))
        total_size=$((total_size + dir_size))
    done
    
    echo
    printf "%-30s %15s %15s\n" "TOTAL" "$total_files" "$(format_bytes $total_size)"
    echo
}

# Function to display extension breakdown
display_extension_breakdown() {
    if [[ ${#extension_counts[@]} -eq 0 ]]; then
        return
    fi
    
    print_colored "$COLOR_BLUE" "=== File Type Breakdown ==="
    echo
    
    # Sort extensions by count (descending)
    local sorted_extensions
    sorted_extensions=$(for ext in "${!extension_counts[@]}"; do
        echo "${extension_counts[$ext]} $ext ${extension_sizes[$ext]}"
    done | sort -rn)
    
    printf "%-20s %15s %15s %15s\n" "Extension" "Count" "Total Size" "Avg Size"
    printf "%-20s %15s %15s %15s\n" "$(printf '%*s' 20 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')"
    
    while read -r count ext total_size; do
        if [[ -n "$count" && -n "$ext" && -n "$total_size" ]]; then
            local avg_size=$((total_size / count))
            printf "%-20s %15s %15s %15s\n" "$ext" "$count" "$(format_bytes $total_size)" "$(format_bytes $avg_size)"
        fi
    done <<< "$sorted_extensions"
    
    echo
}

# Function to display zero-byte files
display_zero_files() {
    if [[ ${#zero_files[@]} -eq 0 ]]; then
        return
    fi
    
    print_colored "$COLOR_BLUE" "=== Zero-Byte Files ==="
    print_colored "$COLOR_RED" "Found ${#zero_files[@]} zero-byte files (potential issues):"
    echo
    
    local count=0
    for file in "${zero_files[@]}"; do
        if [[ $count -lt 20 || "$VERBOSE" == true ]]; then
            echo "  $file"
        fi
        count=$((count + 1))
    done
    
    if [[ $count -gt 20 && "$VERBOSE" == false ]]; then
        print_colored "$COLOR_YELLOW" "  ... and $((count - 20)) more (use -v to see all)"
    fi
    
    echo
}

# Function to display largest files
display_large_files() {
    if [[ ${#large_files[@]} -eq 0 ]]; then
        return
    fi
    
    print_colored "$COLOR_BLUE" "=== Largest Files ==="
    echo
    
    # Sort large files by size (descending)
    local sorted_large_files
    sorted_large_files=$(for file_info in "${large_files[@]}"; do
        local file="${file_info%:*}"
        local size="${file_info##*:}"
        echo "$size $file"
    done | sort -rn | head -n 10)
    
    printf "%-15s %s\n" "Size" "File"
    printf "%-15s %s\n" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 50 '' | tr ' ' '-')"
    
    while read -r size file; do
        if [[ -n "$size" && -n "$file" ]]; then
            printf "%-15s %s\n" "$(format_bytes $size)" "$file"
        fi
    done <<< "$sorted_large_files"
    
    echo
}

# Function to display recent files
display_recent_files() {
    if [[ ${#recent_files[@]} -eq 0 || -z "$RECENT_HOURS" ]]; then
        return
    fi
    
    print_colored "$COLOR_BLUE" "=== Recent Files (Last $RECENT_HOURS Hours) ==="
    echo
    
    # Sort recent files by modification time (newest first)
    local sorted_recent_files
    sorted_recent_files=$(for file_info in "${recent_files[@]}"; do
        local file="${file_info%:*}"
        local size="${file_info##*:}"
        local mtime
        mtime=$(stat -c %Y "$file" 2>/dev/null || echo "0")
        echo "$mtime $size $file"
    done | sort -rn | head -n 20)
    
    printf "%-20s %-15s %s\n" "Modified" "Size" "File"
    printf "%-20s %-15s %s\n" "$(printf '%*s' 20 '' | tr ' ' '-')" "$(printf '%*s' 15 '' | tr ' ' '-')" "$(printf '%*s' 30 '' | tr ' ' '-')"
    
    while read -r mtime size file; do
        if [[ -n "$mtime" && -n "$size" && -n "$file" ]]; then
            local formatted_time
            formatted_time=$(date -d "@$mtime" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "Unknown")
            printf "%-20s %-15s %s\n" "$formatted_time" "$(format_bytes $size)" "$file"
        fi
    done <<< "$sorted_recent_files"
    
    echo
}

# Function to display directory tree
display_directory_tree() {
    if [[ "$SHOW_TREE" == false ]]; then
        return
    fi
    
    print_colored "$COLOR_BLUE" "=== Directory Structure ==="
    echo
    
    # Combine all directories to analyze
    local all_dirs=("${OUTPUT_DIRS[@]}")
    for dir in "${ADDITIONAL_DIRS[@]}"; do
        all_dirs+=("$dir")
    done
    
    for dir in "${all_dirs[@]}"; do
        local full_path="$WORK_DIR/$dir"
        if [[ -d "$full_path" ]]; then
            print_colored "$COLOR_CYAN" "$dir/"
            if command -v tree >/dev/null 2>&1; then
                tree -L 2 "$full_path" 2>/dev/null || find "$full_path" -maxdepth 2 -type d | head -n 20
            else
                find "$full_path" -maxdepth 2 -type d | head -n 20 | sed 's|^'"$full_path"'||' | sed 's|^/||' | sort
            fi
            echo
        fi
    done
}

# Function to provide analysis recommendations
display_recommendations() {
    print_colored "$COLOR_BLUE" "=== Analysis Recommendations ==="
    echo
    
    # Check for zero-byte files
    if [[ ${#zero_files[@]} -gt 0 ]]; then
        print_colored "$COLOR_YELLOW" "Zero-byte files detected (${#zero_files[@]} files):"
        echo "  • These may indicate failed processing or interrupted jobs"
        echo "  • Consider investigating the cause and reprocessing affected data"
        echo
    fi
    
    # Check for very large files
    if [[ ${#large_files[@]} -gt 0 ]]; then
        print_colored "$COLOR_YELLOW" "Large files detected (${#large_files[@]} files >100MB):"
        echo "  • Monitor disk space usage regularly"
        echo "  • Consider compression or archival for completed files"
        echo "  • Review processing efficiency for unusually large outputs"
        echo
    fi
    
    # Check for file count imbalances
    local max_files=0
    local min_files=999999999
    for count in "${dir_file_counts[@]}"; do
        if [[ $count -gt $max_files ]]; then
            max_files=$count
        fi
        if [[ $count -lt $min_files ]]; then
            min_files=$count
        fi
    done
    
    if [[ $max_files -gt 0 && $min_files -ge 0 && $((max_files / (min_files + 1))) -gt 10 ]]; then
        print_colored "$COLOR_YELLOW" "File count imbalance detected:"
        echo "  • Some directories have significantly more files than others"
        echo "  • This may indicate uneven processing or configuration issues"
        echo "  • Consider reviewing job distribution and load balancing"
        echo
    fi
}

# Main analysis function
analyze_files() {
    print_colored "$COLOR_BLUE" "=== File Analysis and Inspection ==="
    print_colored "$COLOR_CYAN" "Timestamp: $(get_timestamp)"
    print_colored "$COLOR_CYAN" "Working Directory: $WORK_DIR"
    
    if [[ -n "$SPECIFIC_EXTENSION" ]]; then
        print_colored "$COLOR_CYAN" "Extension Filter: $SPECIFIC_EXTENSION"
    fi
    
    if [[ -n "$RECENT_HOURS" ]]; then
        print_colored "$COLOR_CYAN" "Time Filter: Last $RECENT_HOURS hours"
    fi
    
    echo
    
    # Combine default and additional directories
    local all_dirs=()
    for dir in "${OUTPUT_DIRS[@]}"; do
        all_dirs+=("$WORK_DIR/$dir")
    done
    for dir in "${ADDITIONAL_DIRS[@]}"; do
        if [[ "$dir" == /* ]]; then
            all_dirs+=("$dir")  # Absolute path
        else
            all_dirs+=("$WORK_DIR/$dir")  # Relative path
        fi
    done
    
    # Analyze each directory
    for dir in "${all_dirs[@]}"; do
        analyze_directory "$dir"
    done
    
    echo
    
    # Display results
    display_directory_summary
    
    if [[ "$SUMMARY_ONLY" == false ]]; then
        display_extension_breakdown
        
        if [[ "$SHOW_ZERO_FILES" == true ]]; then
            display_zero_files
        fi
        
        if [[ "$SHOW_LARGE_FILES" == true ]]; then
            display_large_files
        fi
        
        if [[ -n "$RECENT_HOURS" ]]; then
            display_recent_files
        fi
        
        display_directory_tree
        display_recommendations
    fi
}

# Main execution
main() {
    parse_args "$@"
    analyze_files
}

# Execute main function with all arguments
main "$@"
